/*************  ESP32 + YF-S201 + Blynk Legacy (custom server) + NTP + Auto Reset + Round Baht  *************/
#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
#include <EEPROM.h>
#include <math.h>
#include "time.h"

#define BLYNK_PRINT Serial

/*************  Blynk / WiFi  *************/
char auth[]         = "L5ecyjAhHycvXIPjy3nUVNvaGXvUBJih";
char ssid[]         = "Aticha";
char pass[]         = "0807450025";
char blynk_server[] = "iotservices.thddns.net";
int  blynk_port     = 5535;

/*************  NTP (à¹€à¸§à¸¥à¸²à¹„à¸—à¸¢)  *************/
const char* ntp1 = "th.pool.ntp.org";
const char* ntp2 = "pool.ntp.org";
const char* ntp3 = "time.nist.gov";
const long  gmtOffset_sec      = 7 * 3600;
const int   daylightOffset_sec = 0;

/*************  Sensor (YF-S201)  *************/
#define flowPin 4
volatile int pulseCount = 0;
float calibrationFactor = 4.5;   // YF-S201 ~7.5 à¹‚à¸”à¸¢à¸—à¸±à¹ˆà¸§à¹„à¸›
float flowRate = 0.0;
float totalLiters = 0.0;
float oldTotal = 0.0;

/*************  Billing params  *************/
float pricePerUnit = 24.0;   // à¸šà¸²à¸—/à¸«à¸™à¹ˆà¸§à¸¢
float roomPrice    = 2500.0; // à¸šà¸²à¸—
int   resetDay     = 1;

/*************  EEPROM *************/
#define EEPROM_SIZE 64
#define ADDR_TOTAL 0
#define ADDR_OLD 8
#define ADDR_LAST_MONTH 16
int8_t lastResetMonth = -1;

/*************  Blynk  *************/
BlynkTimer timer;

/* ========= Interrupt ========= */
void IRAM_ATTR pulseCounter() { pulseCount++; }

/* ========= EEPROM ========= */
void loadEEPROM() {
  EEPROM.get(ADDR_TOTAL, totalLiters);
  EEPROM.get(ADDR_OLD, oldTotal);
  EEPROM.get(ADDR_LAST_MONTH, lastResetMonth);
  if (!isfinite(totalLiters) || totalLiters < 0) totalLiters = 0;
  if (!isfinite(oldTotal)    || oldTotal < 0)    oldTotal = totalLiters;
}
inline void saveTotal()     { EEPROM.put(ADDR_TOTAL, totalLiters); EEPROM.commit(); }
inline void saveOld()       { EEPROM.put(ADDR_OLD, oldTotal); EEPROM.commit(); }
inline void saveLastMonth() { EEPROM.put(ADDR_LAST_MONTH, lastResetMonth); EEPROM.commit(); }

/* ========= Blynk events ========= */
BLYNK_CONNECTED() { Serial.println("âœ… Connected to Blynk"); }

/* à¸•à¸±à¹‰à¸‡à¸§à¸±à¸™à¸•à¸±à¸”à¸£à¸­à¸š */
BLYNK_WRITE(V6) {
  resetDay = constrain(param.asInt(), 1, 31);
  Serial.println("ðŸ“… Reset day = " + String(resetDay));
}

/* à¸•à¸±à¹‰à¸‡à¸«à¸™à¹ˆà¸§à¸¢à¹€à¸à¹ˆà¸²à¸”à¹‰à¸§à¸¢à¸¡à¸·à¸­ */
BLYNK_WRITE(V9) {
  float v = param.asFloat();
  if (!isfinite(v) || v < 0) v = 0;
  oldTotal = v;
  saveOld();
  Blynk.virtualWrite(V0, oldTotal);
  Serial.println("âœ… Set oldTotal = " + String(oldTotal));
}

/* à¸•à¸±à¹‰à¸‡à¸«à¸™à¹ˆà¸§à¸¢à¹ƒà¸«à¸¡à¹ˆà¸”à¹‰à¸§à¸¢à¸¡à¸·à¸­ */
BLYNK_WRITE(V11) {
  float v = param.asFloat();
  if (!isfinite(v) || v < 0) v = 0;
  totalLiters = v;
  saveTotal();
  float usedUnit = max(0.0f, totalLiters - oldTotal);
  float waterTotal = usedUnit * pricePerUnit;
  float totalPrice = waterTotal + roomPrice;
  int waterBaht = (int)roundf(waterTotal);
  int roomBaht  = (int)roundf(roomPrice);
  int totalBaht = (int)roundf(totalPrice);
  Blynk.virtualWrite(V1, (int)roundf(totalLiters));
  Blynk.virtualWrite(V2, (int)roundf(usedUnit));
  Blynk.virtualWrite(V4, String(waterBaht));
  Blynk.virtualWrite(V5, String(roomBaht));
  Blynk.virtualWrite(V7, String(totalBaht));
  Serial.printf("âœ… new:%d used:%d | water=%d à¸¿ | room=%d à¸¿ | total=%d à¸¿\n",
                (int)roundf(totalLiters), (int)roundf(usedUnit),
                waterBaht, roomBaht, totalBaht);
}

/* à¸›à¸¸à¹ˆà¸¡à¸£à¸µà¹€à¸‹à¹‡à¸•à¸—à¸±à¸™à¸—à¸µ */
BLYNK_WRITE(V10) {
  if (param.asInt() == 1) {
    oldTotal = totalLiters;
    saveOld();
    struct tm t;
    if (getLocalTime(&t)) { lastResetMonth = t.tm_mon; saveLastMonth(); }
    Blynk.virtualWrite(V0, oldTotal);
    Serial.println("ðŸ”˜ Manual reset â†’ oldTotal = " + String(oldTotal));
  }
}

/* ========= NTP + Date ========= */
bool getNow(struct tm &t) { return getLocalTime(&t); }
void pushDateToBlynk() {
  struct tm t;
  if (getNow(t)) {
    char buf[16];
    strftime(buf, sizeof(buf), "%d/%m/%Y", &t);
    Blynk.virtualWrite(V8, buf);
  }
}

/* ========= Auto monthly reset ========= */
void checkResetDay() {
  struct tm t;
  if (!getNow(t)) return;
  if (t.tm_mday == resetDay && t.tm_hour == 0 && t.tm_min == 0 && t.tm_sec < 10) {
    if (lastResetMonth != t.tm_mon) {
      oldTotal = totalLiters;
      saveOld();
      lastResetMonth = t.tm_mon;
      saveLastMonth();
      Blynk.virtualWrite(V0, oldTotal);
      Serial.println("â™»ï¸ Auto reset done");
      delay(10000);
    }
  }
}

/* ========= à¸„à¸³à¸™à¸§à¸“à¹à¸¥à¸°à¸ªà¹ˆà¸‡à¸„à¹ˆà¸² ========= */
void computeAndPush() {
  static unsigned long lastMs = millis();
  detachInterrupt(digitalPinToInterrupt(flowPin));
  unsigned long now = millis();
  unsigned long dt = now - lastMs; if (dt == 0) dt = 1;
  float pulsesPerSec = (pulseCount * 1000.0) / (float)dt;
  flowRate = pulsesPerSec / calibrationFactor;
  pulseCount = 0;
  lastMs = now;
  attachInterrupt(digitalPinToInterrupt(flowPin), pulseCounter, FALLING);

  totalLiters += (flowRate / 60.0);
  saveTotal();

  float startUnit = oldTotal;
  float endUnit = totalLiters;
  float usedUnit = max(0.0f, endUnit - startUnit);
  float waterTotal = usedUnit * pricePerUnit;
  float totalPrice = waterTotal + roomPrice;

  int sI = (int)roundf(startUnit);
  int eI = (int)roundf(endUnit);
  int uI = (int)roundf(usedUnit);
  int waterBaht = (int)roundf(waterTotal);
  int roomBaht  = (int)roundf(roomPrice);
  int totalBaht = (int)roundf(totalPrice);

  Blynk.virtualWrite(V0, String(sI));
  Blynk.virtualWrite(V1, String(eI));
  Blynk.virtualWrite(V2, String(uI));
  Blynk.virtualWrite(V4, String(waterBaht));
  Blynk.virtualWrite(V5, String(roomBaht));
  Blynk.virtualWrite(V7, String(totalBaht));

  Serial.printf("ðŸ’§ old:%d new:%d used:%d | water=%d à¸¿ | room=%d à¸¿ | total=%d à¸¿\n",
                sI, eI, uI, waterBaht, roomBaht, totalBaht);
}

/* ========= Setup / Loop ========= */
void setup() {
  Serial.begin(115200);
  delay(300);
  WiFi.begin(ssid, pass);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) { delay(400); Serial.print("."); }
  Serial.println("\nâœ… WiFi connected");
  configTime(gmtOffset_sec, daylightOffset_sec, ntp1, ntp2, ntp3);
  Blynk.config(auth, blynk_server, blynk_port);
  Blynk.connect();
  EEPROM.begin(EEPROM_SIZE);
  loadEEPROM();
  pinMode(flowPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(flowPin), pulseCounter, FALLING);
  timer.setInterval(1000, computeAndPush);
  timer.setInterval(1000, checkResetDay);
  timer.setInterval(5000, pushDateToBlynk);
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    Blynk.run();
    if (!Blynk.connected()) Blynk.connect();
  }
  timer.run();
}
